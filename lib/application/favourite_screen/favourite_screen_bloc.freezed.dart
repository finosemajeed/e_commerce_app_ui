// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'favourite_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FavouriteScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() favouriteInitial,
    required TResult Function(Products item) favouriteItemAdded,
    required TResult Function(Products item) favouriteItemRemoved,
    required TResult Function(int item) favouriteCheck,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? favouriteInitial,
    TResult? Function(Products item)? favouriteItemAdded,
    TResult? Function(Products item)? favouriteItemRemoved,
    TResult? Function(int item)? favouriteCheck,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? favouriteInitial,
    TResult Function(Products item)? favouriteItemAdded,
    TResult Function(Products item)? favouriteItemRemoved,
    TResult Function(int item)? favouriteCheck,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavouriteInitial value) favouriteInitial,
    required TResult Function(FavouriteItemAdded value) favouriteItemAdded,
    required TResult Function(FavouriteItemRemoved value) favouriteItemRemoved,
    required TResult Function(FavouriteCheck value) favouriteCheck,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FavouriteInitial value)? favouriteInitial,
    TResult? Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult? Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult? Function(FavouriteCheck value)? favouriteCheck,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavouriteInitial value)? favouriteInitial,
    TResult Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult Function(FavouriteCheck value)? favouriteCheck,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavouriteScreenEventCopyWith<$Res> {
  factory $FavouriteScreenEventCopyWith(FavouriteScreenEvent value,
          $Res Function(FavouriteScreenEvent) then) =
      _$FavouriteScreenEventCopyWithImpl<$Res, FavouriteScreenEvent>;
}

/// @nodoc
class _$FavouriteScreenEventCopyWithImpl<$Res,
        $Val extends FavouriteScreenEvent>
    implements $FavouriteScreenEventCopyWith<$Res> {
  _$FavouriteScreenEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FavouriteInitialCopyWith<$Res> {
  factory _$$FavouriteInitialCopyWith(
          _$FavouriteInitial value, $Res Function(_$FavouriteInitial) then) =
      __$$FavouriteInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FavouriteInitialCopyWithImpl<$Res>
    extends _$FavouriteScreenEventCopyWithImpl<$Res, _$FavouriteInitial>
    implements _$$FavouriteInitialCopyWith<$Res> {
  __$$FavouriteInitialCopyWithImpl(
      _$FavouriteInitial _value, $Res Function(_$FavouriteInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FavouriteInitial implements FavouriteInitial {
  const _$FavouriteInitial();

  @override
  String toString() {
    return 'FavouriteScreenEvent.favouriteInitial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FavouriteInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() favouriteInitial,
    required TResult Function(Products item) favouriteItemAdded,
    required TResult Function(Products item) favouriteItemRemoved,
    required TResult Function(int item) favouriteCheck,
  }) {
    return favouriteInitial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? favouriteInitial,
    TResult? Function(Products item)? favouriteItemAdded,
    TResult? Function(Products item)? favouriteItemRemoved,
    TResult? Function(int item)? favouriteCheck,
  }) {
    return favouriteInitial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? favouriteInitial,
    TResult Function(Products item)? favouriteItemAdded,
    TResult Function(Products item)? favouriteItemRemoved,
    TResult Function(int item)? favouriteCheck,
    required TResult orElse(),
  }) {
    if (favouriteInitial != null) {
      return favouriteInitial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavouriteInitial value) favouriteInitial,
    required TResult Function(FavouriteItemAdded value) favouriteItemAdded,
    required TResult Function(FavouriteItemRemoved value) favouriteItemRemoved,
    required TResult Function(FavouriteCheck value) favouriteCheck,
  }) {
    return favouriteInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FavouriteInitial value)? favouriteInitial,
    TResult? Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult? Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult? Function(FavouriteCheck value)? favouriteCheck,
  }) {
    return favouriteInitial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavouriteInitial value)? favouriteInitial,
    TResult Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult Function(FavouriteCheck value)? favouriteCheck,
    required TResult orElse(),
  }) {
    if (favouriteInitial != null) {
      return favouriteInitial(this);
    }
    return orElse();
  }
}

abstract class FavouriteInitial implements FavouriteScreenEvent {
  const factory FavouriteInitial() = _$FavouriteInitial;
}

/// @nodoc
abstract class _$$FavouriteItemAddedCopyWith<$Res> {
  factory _$$FavouriteItemAddedCopyWith(_$FavouriteItemAdded value,
          $Res Function(_$FavouriteItemAdded) then) =
      __$$FavouriteItemAddedCopyWithImpl<$Res>;
  @useResult
  $Res call({Products item});
}

/// @nodoc
class __$$FavouriteItemAddedCopyWithImpl<$Res>
    extends _$FavouriteScreenEventCopyWithImpl<$Res, _$FavouriteItemAdded>
    implements _$$FavouriteItemAddedCopyWith<$Res> {
  __$$FavouriteItemAddedCopyWithImpl(
      _$FavouriteItemAdded _value, $Res Function(_$FavouriteItemAdded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = null,
  }) {
    return _then(_$FavouriteItemAdded(
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as Products,
    ));
  }
}

/// @nodoc

class _$FavouriteItemAdded implements FavouriteItemAdded {
  const _$FavouriteItemAdded({required this.item});

  @override
  final Products item;

  @override
  String toString() {
    return 'FavouriteScreenEvent.favouriteItemAdded(item: $item)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FavouriteItemAdded &&
            (identical(other.item, item) || other.item == item));
  }

  @override
  int get hashCode => Object.hash(runtimeType, item);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FavouriteItemAddedCopyWith<_$FavouriteItemAdded> get copyWith =>
      __$$FavouriteItemAddedCopyWithImpl<_$FavouriteItemAdded>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() favouriteInitial,
    required TResult Function(Products item) favouriteItemAdded,
    required TResult Function(Products item) favouriteItemRemoved,
    required TResult Function(int item) favouriteCheck,
  }) {
    return favouriteItemAdded(item);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? favouriteInitial,
    TResult? Function(Products item)? favouriteItemAdded,
    TResult? Function(Products item)? favouriteItemRemoved,
    TResult? Function(int item)? favouriteCheck,
  }) {
    return favouriteItemAdded?.call(item);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? favouriteInitial,
    TResult Function(Products item)? favouriteItemAdded,
    TResult Function(Products item)? favouriteItemRemoved,
    TResult Function(int item)? favouriteCheck,
    required TResult orElse(),
  }) {
    if (favouriteItemAdded != null) {
      return favouriteItemAdded(item);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavouriteInitial value) favouriteInitial,
    required TResult Function(FavouriteItemAdded value) favouriteItemAdded,
    required TResult Function(FavouriteItemRemoved value) favouriteItemRemoved,
    required TResult Function(FavouriteCheck value) favouriteCheck,
  }) {
    return favouriteItemAdded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FavouriteInitial value)? favouriteInitial,
    TResult? Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult? Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult? Function(FavouriteCheck value)? favouriteCheck,
  }) {
    return favouriteItemAdded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavouriteInitial value)? favouriteInitial,
    TResult Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult Function(FavouriteCheck value)? favouriteCheck,
    required TResult orElse(),
  }) {
    if (favouriteItemAdded != null) {
      return favouriteItemAdded(this);
    }
    return orElse();
  }
}

abstract class FavouriteItemAdded implements FavouriteScreenEvent {
  const factory FavouriteItemAdded({required final Products item}) =
      _$FavouriteItemAdded;

  Products get item;
  @JsonKey(ignore: true)
  _$$FavouriteItemAddedCopyWith<_$FavouriteItemAdded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FavouriteItemRemovedCopyWith<$Res> {
  factory _$$FavouriteItemRemovedCopyWith(_$FavouriteItemRemoved value,
          $Res Function(_$FavouriteItemRemoved) then) =
      __$$FavouriteItemRemovedCopyWithImpl<$Res>;
  @useResult
  $Res call({Products item});
}

/// @nodoc
class __$$FavouriteItemRemovedCopyWithImpl<$Res>
    extends _$FavouriteScreenEventCopyWithImpl<$Res, _$FavouriteItemRemoved>
    implements _$$FavouriteItemRemovedCopyWith<$Res> {
  __$$FavouriteItemRemovedCopyWithImpl(_$FavouriteItemRemoved _value,
      $Res Function(_$FavouriteItemRemoved) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = null,
  }) {
    return _then(_$FavouriteItemRemoved(
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as Products,
    ));
  }
}

/// @nodoc

class _$FavouriteItemRemoved implements FavouriteItemRemoved {
  const _$FavouriteItemRemoved({required this.item});

  @override
  final Products item;

  @override
  String toString() {
    return 'FavouriteScreenEvent.favouriteItemRemoved(item: $item)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FavouriteItemRemoved &&
            (identical(other.item, item) || other.item == item));
  }

  @override
  int get hashCode => Object.hash(runtimeType, item);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FavouriteItemRemovedCopyWith<_$FavouriteItemRemoved> get copyWith =>
      __$$FavouriteItemRemovedCopyWithImpl<_$FavouriteItemRemoved>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() favouriteInitial,
    required TResult Function(Products item) favouriteItemAdded,
    required TResult Function(Products item) favouriteItemRemoved,
    required TResult Function(int item) favouriteCheck,
  }) {
    return favouriteItemRemoved(item);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? favouriteInitial,
    TResult? Function(Products item)? favouriteItemAdded,
    TResult? Function(Products item)? favouriteItemRemoved,
    TResult? Function(int item)? favouriteCheck,
  }) {
    return favouriteItemRemoved?.call(item);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? favouriteInitial,
    TResult Function(Products item)? favouriteItemAdded,
    TResult Function(Products item)? favouriteItemRemoved,
    TResult Function(int item)? favouriteCheck,
    required TResult orElse(),
  }) {
    if (favouriteItemRemoved != null) {
      return favouriteItemRemoved(item);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavouriteInitial value) favouriteInitial,
    required TResult Function(FavouriteItemAdded value) favouriteItemAdded,
    required TResult Function(FavouriteItemRemoved value) favouriteItemRemoved,
    required TResult Function(FavouriteCheck value) favouriteCheck,
  }) {
    return favouriteItemRemoved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FavouriteInitial value)? favouriteInitial,
    TResult? Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult? Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult? Function(FavouriteCheck value)? favouriteCheck,
  }) {
    return favouriteItemRemoved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavouriteInitial value)? favouriteInitial,
    TResult Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult Function(FavouriteCheck value)? favouriteCheck,
    required TResult orElse(),
  }) {
    if (favouriteItemRemoved != null) {
      return favouriteItemRemoved(this);
    }
    return orElse();
  }
}

abstract class FavouriteItemRemoved implements FavouriteScreenEvent {
  const factory FavouriteItemRemoved({required final Products item}) =
      _$FavouriteItemRemoved;

  Products get item;
  @JsonKey(ignore: true)
  _$$FavouriteItemRemovedCopyWith<_$FavouriteItemRemoved> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FavouriteCheckCopyWith<$Res> {
  factory _$$FavouriteCheckCopyWith(
          _$FavouriteCheck value, $Res Function(_$FavouriteCheck) then) =
      __$$FavouriteCheckCopyWithImpl<$Res>;
  @useResult
  $Res call({int item});
}

/// @nodoc
class __$$FavouriteCheckCopyWithImpl<$Res>
    extends _$FavouriteScreenEventCopyWithImpl<$Res, _$FavouriteCheck>
    implements _$$FavouriteCheckCopyWith<$Res> {
  __$$FavouriteCheckCopyWithImpl(
      _$FavouriteCheck _value, $Res Function(_$FavouriteCheck) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = null,
  }) {
    return _then(_$FavouriteCheck(
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FavouriteCheck implements FavouriteCheck {
  const _$FavouriteCheck({required this.item});

  @override
  final int item;

  @override
  String toString() {
    return 'FavouriteScreenEvent.favouriteCheck(item: $item)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FavouriteCheck &&
            (identical(other.item, item) || other.item == item));
  }

  @override
  int get hashCode => Object.hash(runtimeType, item);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FavouriteCheckCopyWith<_$FavouriteCheck> get copyWith =>
      __$$FavouriteCheckCopyWithImpl<_$FavouriteCheck>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() favouriteInitial,
    required TResult Function(Products item) favouriteItemAdded,
    required TResult Function(Products item) favouriteItemRemoved,
    required TResult Function(int item) favouriteCheck,
  }) {
    return favouriteCheck(item);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? favouriteInitial,
    TResult? Function(Products item)? favouriteItemAdded,
    TResult? Function(Products item)? favouriteItemRemoved,
    TResult? Function(int item)? favouriteCheck,
  }) {
    return favouriteCheck?.call(item);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? favouriteInitial,
    TResult Function(Products item)? favouriteItemAdded,
    TResult Function(Products item)? favouriteItemRemoved,
    TResult Function(int item)? favouriteCheck,
    required TResult orElse(),
  }) {
    if (favouriteCheck != null) {
      return favouriteCheck(item);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavouriteInitial value) favouriteInitial,
    required TResult Function(FavouriteItemAdded value) favouriteItemAdded,
    required TResult Function(FavouriteItemRemoved value) favouriteItemRemoved,
    required TResult Function(FavouriteCheck value) favouriteCheck,
  }) {
    return favouriteCheck(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FavouriteInitial value)? favouriteInitial,
    TResult? Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult? Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult? Function(FavouriteCheck value)? favouriteCheck,
  }) {
    return favouriteCheck?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavouriteInitial value)? favouriteInitial,
    TResult Function(FavouriteItemAdded value)? favouriteItemAdded,
    TResult Function(FavouriteItemRemoved value)? favouriteItemRemoved,
    TResult Function(FavouriteCheck value)? favouriteCheck,
    required TResult orElse(),
  }) {
    if (favouriteCheck != null) {
      return favouriteCheck(this);
    }
    return orElse();
  }
}

abstract class FavouriteCheck implements FavouriteScreenEvent {
  const factory FavouriteCheck({required final int item}) = _$FavouriteCheck;

  int get item;
  @JsonKey(ignore: true)
  _$$FavouriteCheckCopyWith<_$FavouriteCheck> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FavouriteScreenState {
  bool get isLoading => throw _privateConstructorUsedError;
  bool get isError => throw _privateConstructorUsedError;
  bool get isFavourite => throw _privateConstructorUsedError;
  List<Products>? get favouriteItems => throw _privateConstructorUsedError;
  bool get favouriteAdded => throw _privateConstructorUsedError;
  bool get favouriteRemoved => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FavouriteScreenStateCopyWith<FavouriteScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavouriteScreenStateCopyWith<$Res> {
  factory $FavouriteScreenStateCopyWith(FavouriteScreenState value,
          $Res Function(FavouriteScreenState) then) =
      _$FavouriteScreenStateCopyWithImpl<$Res, FavouriteScreenState>;
  @useResult
  $Res call(
      {bool isLoading,
      bool isError,
      bool isFavourite,
      List<Products>? favouriteItems,
      bool favouriteAdded,
      bool favouriteRemoved});
}

/// @nodoc
class _$FavouriteScreenStateCopyWithImpl<$Res,
        $Val extends FavouriteScreenState>
    implements $FavouriteScreenStateCopyWith<$Res> {
  _$FavouriteScreenStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? isError = null,
    Object? isFavourite = null,
    Object? favouriteItems = freezed,
    Object? favouriteAdded = null,
    Object? favouriteRemoved = null,
  }) {
    return _then(_value.copyWith(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isError: null == isError
          ? _value.isError
          : isError // ignore: cast_nullable_to_non_nullable
              as bool,
      isFavourite: null == isFavourite
          ? _value.isFavourite
          : isFavourite // ignore: cast_nullable_to_non_nullable
              as bool,
      favouriteItems: freezed == favouriteItems
          ? _value.favouriteItems
          : favouriteItems // ignore: cast_nullable_to_non_nullable
              as List<Products>?,
      favouriteAdded: null == favouriteAdded
          ? _value.favouriteAdded
          : favouriteAdded // ignore: cast_nullable_to_non_nullable
              as bool,
      favouriteRemoved: null == favouriteRemoved
          ? _value.favouriteRemoved
          : favouriteRemoved // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FavouriteScreenStateCopyWith<$Res>
    implements $FavouriteScreenStateCopyWith<$Res> {
  factory _$$_FavouriteScreenStateCopyWith(_$_FavouriteScreenState value,
          $Res Function(_$_FavouriteScreenState) then) =
      __$$_FavouriteScreenStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isLoading,
      bool isError,
      bool isFavourite,
      List<Products>? favouriteItems,
      bool favouriteAdded,
      bool favouriteRemoved});
}

/// @nodoc
class __$$_FavouriteScreenStateCopyWithImpl<$Res>
    extends _$FavouriteScreenStateCopyWithImpl<$Res, _$_FavouriteScreenState>
    implements _$$_FavouriteScreenStateCopyWith<$Res> {
  __$$_FavouriteScreenStateCopyWithImpl(_$_FavouriteScreenState _value,
      $Res Function(_$_FavouriteScreenState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? isError = null,
    Object? isFavourite = null,
    Object? favouriteItems = freezed,
    Object? favouriteAdded = null,
    Object? favouriteRemoved = null,
  }) {
    return _then(_$_FavouriteScreenState(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isError: null == isError
          ? _value.isError
          : isError // ignore: cast_nullable_to_non_nullable
              as bool,
      isFavourite: null == isFavourite
          ? _value.isFavourite
          : isFavourite // ignore: cast_nullable_to_non_nullable
              as bool,
      favouriteItems: freezed == favouriteItems
          ? _value._favouriteItems
          : favouriteItems // ignore: cast_nullable_to_non_nullable
              as List<Products>?,
      favouriteAdded: null == favouriteAdded
          ? _value.favouriteAdded
          : favouriteAdded // ignore: cast_nullable_to_non_nullable
              as bool,
      favouriteRemoved: null == favouriteRemoved
          ? _value.favouriteRemoved
          : favouriteRemoved // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_FavouriteScreenState implements _FavouriteScreenState {
  const _$_FavouriteScreenState(
      {required this.isLoading,
      required this.isError,
      required this.isFavourite,
      required final List<Products>? favouriteItems,
      required this.favouriteAdded,
      required this.favouriteRemoved})
      : _favouriteItems = favouriteItems;

  @override
  final bool isLoading;
  @override
  final bool isError;
  @override
  final bool isFavourite;
  final List<Products>? _favouriteItems;
  @override
  List<Products>? get favouriteItems {
    final value = _favouriteItems;
    if (value == null) return null;
    if (_favouriteItems is EqualUnmodifiableListView) return _favouriteItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool favouriteAdded;
  @override
  final bool favouriteRemoved;

  @override
  String toString() {
    return 'FavouriteScreenState(isLoading: $isLoading, isError: $isError, isFavourite: $isFavourite, favouriteItems: $favouriteItems, favouriteAdded: $favouriteAdded, favouriteRemoved: $favouriteRemoved)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FavouriteScreenState &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.isError, isError) || other.isError == isError) &&
            (identical(other.isFavourite, isFavourite) ||
                other.isFavourite == isFavourite) &&
            const DeepCollectionEquality()
                .equals(other._favouriteItems, _favouriteItems) &&
            (identical(other.favouriteAdded, favouriteAdded) ||
                other.favouriteAdded == favouriteAdded) &&
            (identical(other.favouriteRemoved, favouriteRemoved) ||
                other.favouriteRemoved == favouriteRemoved));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isLoading,
      isError,
      isFavourite,
      const DeepCollectionEquality().hash(_favouriteItems),
      favouriteAdded,
      favouriteRemoved);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FavouriteScreenStateCopyWith<_$_FavouriteScreenState> get copyWith =>
      __$$_FavouriteScreenStateCopyWithImpl<_$_FavouriteScreenState>(
          this, _$identity);
}

abstract class _FavouriteScreenState implements FavouriteScreenState {
  const factory _FavouriteScreenState(
      {required final bool isLoading,
      required final bool isError,
      required final bool isFavourite,
      required final List<Products>? favouriteItems,
      required final bool favouriteAdded,
      required final bool favouriteRemoved}) = _$_FavouriteScreenState;

  @override
  bool get isLoading;
  @override
  bool get isError;
  @override
  bool get isFavourite;
  @override
  List<Products>? get favouriteItems;
  @override
  bool get favouriteAdded;
  @override
  bool get favouriteRemoved;
  @override
  @JsonKey(ignore: true)
  _$$_FavouriteScreenStateCopyWith<_$_FavouriteScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}
